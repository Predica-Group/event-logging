# Event Logging

_Event Logging_ is an API for logging events conforming to the [_Event Logging XML Schema_](https://github.com/gchq/event-logging-schema).
The API uses a generated Java JAXB model of _Event Logging XML Schema_.
_Event Logging_ can be incorporated into your Java application to provide a means of recording and outputting audit events.

## Using the _Event Logging_ API

### Gradle/Maven dependencies

The Event Logging API is available as a Maven/Gradle dependency on [Bintray](https://bintray.com/stroom/event-logging/event-logging).
To include it in your Gradle build add the following:

```groovy
repositories {
  //...
  maven { url "https://dl.bintray.com/stroom/event-logging" }
}

//...

dependencies {
  compile 'event-logging:event-logging:v4.0.7_schema-v3.2.4'
}
```

> **NOTE**:  
Version 3.x.x+ of event-logging is compatible with Java 8+  

The second version number in the version string is the version of the _event-logging-schema_ XML Schema that the library uses.

### Calling the API

The API has two main parts, the class model that represents the schema and the classes involved with serialising the events.

#### Event Class Model

The class model is autogenerated from the XML schema and includes fluent builder classes and methods to make constructing an event easier.
The top level class for constructing an event is `event.logging.Event`.

```java
final Event event = Event.builder()
        //...
        .build();
```

#### Logging Service

The interface for logging audit events is `LoggingEventsService.java`.
A default implementation of this interface is included in the form of `DefaultEventLoggingService.java`.
This simple implementation serialises the `Event` passed to it to an XML String and passes that to an implementation of `LogReceiver`.

By default this library will use the `LoggerLogReceiver` implementation to receive and handle the XML events.
This implementation will write the XML to an SLF4J logger called `event-logger`.
You then need to add configuration to your logging framework, i.e. Log4J/Logback/etc. to handle the `event-logger` logs, e.g. writing them to rolled log files.

Sending your rolled event logs to Stroom would then be done using something like [send_to_stroom.sh](https://github.com/gchq/stroom-clients/tree/master/bash) or [stroom-log-sender](https://hub.docker.com/r/gchq/stroom-log-sender).

If you don't wish to use the `LoggerLogReceiver` to handle the logs, you can make your own implementation of `LogReceiver`.
In order to use your own implementaion you need to set the system property `event.logging.logreceiver` with the fully qualified class name of your implementation.
`LogReceiverFactory` will then issue new instances of your implementation instead of `LoggerLogReceiver`.

#### Examples

Examples of how to construct various types of events and log them can be found in the test class `base/src/test/java/event/logging/EventLoggingServiceIT.java`.

The following is a very simple example of logging an _Authentication_ type event using the default logging service supplied with the API.

```java
// Create the logging service
final EventLoggingService eventLoggingService = new DefaultEventLoggingService();

// Create the event object
final Event event = eventLoggingService.buildEvent()
        .withEventTime(EventTime.builder()
                .withTimeCreated(new Date())
                .build())
        .withEventSource(EventSource.builder()
                .withSystem(SystemDetail.builder()
                        .withName("Test System")
                        .withEnvironment("Test")
                        .build())
                .withGenerator("JUnit")
                .withDevice(Device.builder()
                        .withIPAddress("123.123.123.123")
                        .build())
                .withUser(User.builder()
                        .withId("someuser")
                        .build())
                .build())
        .withEventDetail(EventDetail.builder()
                .withTypeId("LOGON")
                .withDescription("A user logon")
                .withAuthenticate(AuthenticateEventAction.builder()
                        .withAction(AuthenticateAction.LOGON)
                        .withUser(User.builder()
                                .withId("someuser")
                                .build())
                        .build())
                .build())
        .build();

// Send the event 
eventLoggingService.log(event);
```

Alternatively you can use the fully fluent style (using the `end()` methods on the `Builder` classes) to build the event.
While more compact, this is heavily reliant on careful indentation to ensure readability.

```java
// Create the logging service
final EventLoggingService eventLoggingService = new DefaultEventLoggingService();

// Create the event object
final Event event = eventLoggingService.buildEvent()
        .withEventTime()
                .withTimeCreated(new Date())
                .end()
        .withEventSource()
                .withSystem()
                        .withName("Test System")
                        .withEnvironment("Test")
                        .end()
                .withGenerator("JUnit")
                .withDevice()
                        .withIPAddress("123.123.123.123")
                        .end()
                .withUser()
                        .withId("someuser")
                        .end()
                .end()
        .withEventDetail()
                .withTypeId("LOGON")
                .withDescription("A user logon")
                .withAuthenticate()
                        .withAction(AuthenticateAction.LOGON)
                        .withUser()
                                .withId("someuser")
                                .end()
                        .end()
                .end()
        .build();

// Send the event
eventLoggingService.log(event);
```

A standalone example application can be found in `example-logged-application` that shows how you can include logging in your application, see [here](./example-logged-application/README.md) for details.

_event-logging_ is used by [_Stroom_](https://github.com/gchq/stroom).
An example of how it used can be seen here: [`StroomEventLoggingServiceImpl`](https://github.com/gchq/stroom/blob/master/stroom-event-logging/stroom-event-logging-impl/src/main/java/stroom/event/logging/impl/StroomEventLoggingServiceImpl.java)

## Upgrading from v3/4 to v5

v5 of this library introduces a number of breaking changes that will require you to alter your existing event creation code if migrating to v5.
We appreciate that introducing breaking changes causes a lot of pain and we don't do it lightly.
Unfortunately there were a number of fundamental issues with the previous versions of the library that made it difficult to work with.

### Fluent Builders

v5 has introduced fluent style builder classes and methods for each class in the `Event` model.
These make creating your events easier and neater.
There is however no requirement to change existing code to use the builders.

### Moved Classes

For clarity all classes have been made top-level.
Previously a lot of the classes were declared as static inner classes.
Where this has happened, e.g. `event.logging.Event.EventDetail` => `event.logging.EventDetail`, it should just be case of fixing the import or removing the extra parent class from the qualifier.

### Renamed Classes

The following classes have been renamed:

* `Event.EventDetail.Alert` => `AlertEventAction`
* `Event.EventDetail.Approval` => `ApprovalEventAction`
* `Event.EventDetail.Authenticate` => `AuthenticateEventAction`
* `Event.EventDetail.Authorise` => `AuthoriseEventAction`
* `Event.EventDetail.Authorise` => `AuthoriseEventAction`
* `CopyMove` => `CopyEventAction` & `MoveEventAction`
* `Export` => `ExportEventAction`
* `Import` => `ImportEventAction`
* `Install` => `InstallEventAction` & `InstallEventAction`
* `Event.EventDetail.Network` => `NetworkEventAction`
* `NetworkSrcDst` => `NetworkLocation`
* `NetworkSrcDstTrasnportProtocol` => `NetworkProtocol`
* `NetworkSrcDstTrasnportProtocol` => `NetworkProtocol`
* `Object` => `OtherObject`
* `Event.EventDetail.Print` => `PrintEventAction`
* `Event.EventDetail.Process` => `ProcessEventAction`
* `SendReceive` => `SendEventAction` & `ReceiveEventAction`
* `Search` => `SearchEventAction`
* `Unknown` => `UnknownEventAction`
* `Event.EventDetail.Update` => `UpdateEventAction`

### Type changes

Some properties have had their classes changed for clarity:

* `ObjectOutcome Event.EventDetail.create` => `CreateEventAction EventDetail.create`
* `ObjectOutcome Event.EventDetail.delete` => `DeleteEventAction EventDetail.delete`
* `ObjectOutcome Event.EventDetail.search` => `SearchEventAction EventDetail.search`
* `CopyMove Event.EventDetail.copy` => `CopyEventAction EventDetail.copy`
* `CopyMove Event.EventDetail.move` => `MoveEventAction EventDetail.move`
* `Install Event.EventDetail.uninstall` => `UninstallEventAction EventDetail.uninstall`
* `ObjectOutcome Event.EventDetail.view` => `ViewEventAction EventDetail.view`

### Removed Classes

A number of deprecated classes and properties have been removed:

* `Event.EventDetail.antiMalware`
* `AntiMalware`
* `BaseAdvancedQueryItemComplexType` - replaced with marker interface `AdvancedQueryItem`
* `SearchResult` - use `SearchResults` instead.
* `Event.EventDetail.classification` - use `Event.classification` instead.
* `From`

### New Interfaces

A number of new marker interfaces have been added to make the API clearer.
For example all the possible event actions (e.g. send, create, delete, etc.) under `EventDetail` now implement the marker interface `EventAction`.

## Developing this library

### Generation of the JAXB artefacts

The JAXB artefacts are generated using the _com.sun.tools.xjc_ tool that ships with Java.
This parses the XML Schema and builds a set of classes based on the schema.
_xjc_ is run using a number of additional plugins to handle the creation of fluent builders and common interfaces.
Prior to running _xjc_ the schema undergoes an automated tidy up process to rename many of the elements to improve the class names in the JAXB model, i.e. `FooComplexType` becomes `Foo`.

The generation process is reliant on having the required version of the _Event Logging_ XML schema in the directory _event-logging-generator/schema/_.
This directory is ignored by source control.
The Gradle build will download the schema from GitHub as long as the following line in the root _build.gradle_ file has been set to the correct schema version. 

``` groovy
def eventLoggingSchemaVer = "v3.1.2"
```

The class that manages the code generation is `event.logging.gen.GenClasses`.
As well running `xjc` it copies various non-generated classes and resources into the _event-logging-api_ module from _event-logging-base_ which is what the published jar is ultimately built from.
As part of this copy process any packages or imports for `event.logging.base` are changed to `event.logging` to reflect their new home.

#### Bindings

To further fine tune the code that is generated from the schema, _xjc_ uses a bindings file `simple-binding.xjb`.
This allows us to do things like changing the name of generated classes or making classes implement a non-generated interface.
Note the bindings file is run against a modified version of the source schema (_schema.mod.xsd_) that is produced by _GenClasses_.
The main aim of this is to remove the suffix `ComplexType` from the complex types so that the Java classes don't have this as a suffix.
Because the bindings file operates against the modified schema any xpaths will need to be in terms of that scheme, i.e. `@name='Foo'` rather than `@name='FooComplexType'`.
Any changes to the schema may require changes to the bindings, e.g. the introduction of a new event action would require some additional bindings to make its class implement the `EventAction` interface.

#### Generated Code Comparison

Part of the build process is to compare the generated code against a previous release.
This allows you to see how any change to the schema has impacted the java code.
As the build is unable to determine what constitutes the previous release you need to specify it in the root build file.

``` groovy
ext.previousReleaseVersion = "v4.0.7_schema-v3.2.4"
```

The Gradle build will generate the JAXB artefacts and go onto build the API jar.

The _Event Logging_ XML schema is authored in [github.com/gchq/event-logging-schema](https://github.com/gchq/event-logging-schema).
The _Event Logging XML Schema_ in _event-logging-generator/schema/_ should never be edited directly.
It should always be a copy of the desired version from _event-loggin-schema_.

### Building the _Event Logging_ API jar

The API jar is built using Gradle. This will generate the JAXB artefacts, as well as copying the API classes, test classes and XML schema from the base module into the event-logging-api module.

All files under event-logging-api/src are transient and will be generated or copied in as part of the Gradle build.

The build is run as follows:

`./gradlew clean build`

To run the build with specific version number do something like:

`./gradlew clean build -Pversion=v1.2.3_schema-v4.5.6`

Towards the end of the build process, it will download the sources jar for the latest release of _event-logging_ from GitHub and compare the Java source files in it to those just built.
This provides a quick way of seeing the impact on the API from any changes in the schema.
For example some schema changes that would not be a breaking change as far as an XML document is concerned (e.g. a rename of a complex type), would become a breaking change in the JAXB classes.

### Developing the schema in conjunction with the JAXB library

By default the build will download the _-client_ variant of the schema from github.
This is not ideal when you are making changes to the schema and want to see the impact on the JAXB library.
If you want to run the build using a local copy of the schema you can do something like the following:

```bash
./buildAgainstLocalSchema.sh
```

This will build the _client_ variant of the schema from whatever version of the master `event-logging.xsd` schema is in the local `event-logging-schema` repo, then build _event-logging_ from it.

#### Documentation

The Javadoc for the library is automatically pulled from the schema annotations by `jaxb2-rich-contract-plugin`.
Therefore it is important to ensure that all elements, types and complex types in the schema are fully annotated to provide a rich set of javadocs.

### Releasing the _Event Logging_ API jar

To perform a release simply tag the _master_ branch as follows:

`git tag -a vX.Y.Z_schema-vA.B.C`

Where `X.Y.Z` is the version of the _event-logging_ API library and `A.B.C` is the version of the event-logging XMLSchema.
The two version numbers are totally independent of each other and have different life-cycles, e.g. a minor release of the schema could trigger a breaking change and major release of the API.
Equally there may be a new release of the API with an identical schema version to the previous one.
The build process will validate the tag when it is used as the version property in Travis.

When prompted to enter the commit message set the first line to `event-logging-vX.Y.Z_schema-vA.B.C` and lines 3+ to be the changes made, as extracted from the CHANGELOG.md file.
Once the tag is picked up by Travis, the build will be run and the build artefacts published to [GitHub releases](https://github.com/gchq/event-logging/releases).
